<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Weblog</title><link>https://ronanquigley.com/blog/</link><description>Recent content on Weblog</description><generator>Hugo -- gohugo.io</generator><language>en-uk</language><lastBuildDate>Fri, 19 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://ronanquigley.com/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Benchmarking GPU sharing strategies in Kubernetes</title><link>https://ronanquigley.com/blog/benchmarking-gpu-sharing-strategies-in-kubernetes/</link><pubDate>Fri, 19 Jul 2024 00:00:00 +0000</pubDate><guid>https://ronanquigley.com/blog/benchmarking-gpu-sharing-strategies-in-kubernetes/</guid><description>Benchmarking GPU sharing strategies in Kubernetes This writeup is the conclusion of my previous post. If you don&amp;rsquo;t know what MIG, MPS and Time Slicing do, I&amp;rsquo;d suggest reading that one first.
Before talking about the results, there&amp;rsquo;s one thing worth calling out in the Pytorch notes on CUDA:
By default, GPU operations are asynchronous. When you call a function that uses the GPU, the operations are enqueued to the particular device, but not necessarily executed until later.</description></item><item><title>Understanding GPU sharing strategies in Kubernetes</title><link>https://ronanquigley.com/blog/understanding-gpu-sharing-strategies-in-kubernetes/</link><pubDate>Tue, 11 Jun 2024 14:13:34 +0000</pubDate><guid>https://ronanquigley.com/blog/understanding-gpu-sharing-strategies-in-kubernetes/</guid><description>Understanding GPU sharing strategies in Kubernetes [UPDATE]
I&amp;rsquo;ve now posted my benchmarks, so if you just need to see those stats then have a read of benchmarking-gpu-sharing-strategies-in-kubernetes.
These notes are aimed at anyone that wants to setup Nvidia GPU sharing strategies within k8s without having to trawl through a lot of crypic and dense Nvidia documentation. I&amp;rsquo;m also focusing on a high level ELI5, using the knowledge I&amp;rsquo;ve gained so far on the subject, of:</description></item><item><title>A trick to speed up and slim down bloated Node images</title><link>https://ronanquigley.com/blog/a-trick-to-speed-up-and-slim-down-bloated-node-images/</link><pubDate>Sat, 24 Feb 2024 14:13:34 +0000</pubDate><guid>https://ronanquigley.com/blog/a-trick-to-speed-up-and-slim-down-bloated-node-images/</guid><description>Disclaimer Before reading, you should only need to do this if you cannot use Plug and Play (PnP) from either yarn or pnpm. PnP does not have this issue as it loads modules that are stored as zip files. A single module that is zipped is just 1 file vs potentially 10s if not 100s of 1000s of files coming from each of your dependencies of dependencies of dependencies etc. etc.</description></item></channel></rss>